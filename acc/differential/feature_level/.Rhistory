bar <- foo %>% dcast(id~stage, value.var="rate") %>% .[,diff:=E5.5-E4.5] %>%
.[,cluster:=cut(diff, breaks = c(0,0.05,0.25,1.0))] %>% .[,diff:=NULL] %>%
.[cluster!="(0.05,0.5]"] %>%
# .[,cluster:=ifelse(diff>0.25,"A","B")] %>% .[,cluster:=as.factor(cluster)] %>% .[,diff:=NULL] %>%
melt(id.vars=c("id","cluster"), variable.name="stage", value.name="rate")
p <- ggplot(bar, aes(x=cluster, y=rate, fill=stage)) +
geom_boxplot(alpha=1.0, outlier.shape = NA) +
theme_bw() +
theme(
axis.text.x = element_text(colour="black",size=rel(1.5), angle=90, hjust=1, vjust=0.5)
)
print(p)
# h <- hclust(dist(t(baz)))
# c <- cutree(h, k=2)
# baz <- merge(bar, data.table(id=names(c), cluster=as.factor(c)), by="id")
foo <- data[,.(rate=sum(Nmet)/sum(N)), by=c("id","stage")]
bar <- foo %>% dcast(id~stage, value.var="rate") %>% .[,diff:=E5.5-E4.5] %>%
.[,cluster:=cut(diff, breaks = c(0,0.05,0.25,1.0))] %>% .[,diff:=NULL] %>%
.[cluster!="(0.05,0.25]"] %>%
# .[,cluster:=ifelse(diff>0.25,"A","B")] %>% .[,cluster:=as.factor(cluster)] %>% .[,diff:=NULL] %>%
melt(id.vars=c("id","cluster"), variable.name="stage", value.name="rate")
p <- ggplot(bar, aes(x=cluster, y=rate, fill=stage)) +
geom_boxplot(alpha=1.0, outlier.shape = NA) +
theme_bw() +
theme(
axis.text.x = element_text(colour="black",size=rel(1.5), angle=90, hjust=1, vjust=0.5)
)
print(p)
# Convert from ensembl ID to gene ID
gene.metadata <- fread(io$gene.metadata) %>% .[,c("ens_id","symbol")] %>% setnames(c("id","gene"))
tmp <- merge(bar, gene.metadata, by="id")
# I/O Reactome
io$reactomeFile <- "/Users/ricard/data/reactome/v59/mus_musculus/out/mouse_v75_reactome.rds"
io$reactomeFile2 <- "/Users/ricard/data/reactome/v59/mus_musculus/AllPathways.txt"
# Load reactome files
reactome <- readRDS(io$reactomeFile); colnames(reactome) <- toupper(colnames(reactome))
reactome.tmp <- read.table(io$reactomeFile2, header=F, quote="", sep="\t", stringsAsFactors=F)[,c(1,2)]
reactome_meta <- reactome.tmp[,2]; names(reactome_meta) <- reactome.tmp[,1]
rownames(reactome) <- stringr::str_replace_all(rownames(reactome), reactome_meta)
feature.sets <- reactome
# I/O MSigDB
io$msigFile <- "/Users/ricard/data/MSigDB/v6.0/mus_musculus/C5/bp_binary_matrix_ensembl.rds"
# io$msigFile <- "/Users/ricard/data/MSigDB/v6.0/mus_musculus/C2/binary_matrix_ensembl.rds"
# Load MSigDB files
# feature.sets <- readRDS(io$msigFile)
# Filter feature sets with small number of features
opts$min.size <- 10
feature.sets <- feature.sets[rowSums(feature.sets)>=opts$min.size,]
# Remove features that do not intersect between the feature sets and the data
features <- intersect(toupper(foo$gene),colnames(feature.sets))
tmp_filt <- tmp[,gene:=toupper(gene)] %>% .[gene %in% features]
feature.sets_filt <- feature.sets[,features]
asd <- melt.data.table(as.data.table(feature.sets_filt, keep.rownames="pathway"), id.vars = "pathway", variable.name="gene", value.name="value") %>% merge(tmp_filt[,c("gene","cluster")], allow.cartesian=T, by="gene")
bar
tmp <- merge(bar, gene.metadata, by="id")
dim(tmp)
head(tmp)
# I/O Reactome
io$reactomeFile <- "/Users/ricard/data/reactome/v59/mus_musculus/out/mouse_v75_reactome.rds"
io$reactomeFile2 <- "/Users/ricard/data/reactome/v59/mus_musculus/AllPathways.txt"
# Load reactome files
reactome <- readRDS(io$reactomeFile); colnames(reactome) <- toupper(colnames(reactome))
reactome.tmp <- read.table(io$reactomeFile2, header=F, quote="", sep="\t", stringsAsFactors=F)[,c(1,2)]
reactome_meta <- reactome.tmp[,2]; names(reactome_meta) <- reactome.tmp[,1]
rownames(reactome) <- stringr::str_replace_all(rownames(reactome), reactome_meta)
feature.sets <- reactome
# I/O MSigDB
io$msigFile <- "/Users/ricard/data/MSigDB/v6.0/mus_musculus/C5/bp_binary_matrix_ensembl.rds"
# io$msigFile <- "/Users/ricard/data/MSigDB/v6.0/mus_musculus/C2/binary_matrix_ensembl.rds"
# Filter feature sets with small number of features
opts$min.size <- 10
feature.sets <- feature.sets[rowSums(feature.sets)>=opts$min.size,]
# Remove features that do not intersect between the feature sets and the data
features <- intersect(toupper(foo$gene),colnames(feature.sets))
tmp_filt <- tmp[,gene:=toupper(gene)] %>% .[gene %in% features]
feature.sets_filt <- feature.sets[,features]
head(tmp)
features
# Remove features that do not intersect between the feature sets and the data
features <- intersect(toupper(tmp$gene),colnames(feature.sets))
features
tmp_filt <- tmp[,gene:=toupper(gene)] %>% .[gene %in% features]
feature.sets_filt <- feature.sets[,features]
asd <- melt.data.table(as.data.table(feature.sets_filt, keep.rownames="pathway"), id.vars = "pathway", variable.name="gene", value.name="value") %>% merge(tmp_filt[,c("gene","cluster")], allow.cartesian=T, by="gene")
# Perform Gene ontology enrichment per cluster
go_list <- list()
for (c in unique(asd$cluster)) {
go_list[[c]] <- asd[,.(p=fisher.test(x=matrix(data=c(.SD[cluster==c & value==1,.N],
.SD[cluster!=c & value==1,.N],
.SD[cluster==c & value==0,.N],
.SD[cluster!=c & value==0,.N]),
nrow=2, ncol=2), alternative="greater")[["p.value"]]), by="pathway"] %>% .[,padj:=p.adjust(p, method = "fdr")]
}
View(go_results)
# Load MSigDB files
feature.sets <- readRDS(io$msigFile)
head(colnames(feature.sets))
# Filter feature sets with small number of features
opts$min.size <- 10
feature.sets <- feature.sets[rowSums(feature.sets)>=opts$min.size,]
# Remove features that do not intersect between the feature sets and the data
features <- intersect(toupper(tmp$gene),colnames(feature.sets))
tmp_filt <- tmp[,gene:=toupper(gene)] %>% .[gene %in% features]
feature.sets_filt <- feature.sets[,features]
asd <- melt.data.table(as.data.table(feature.sets_filt, keep.rownames="pathway"), id.vars = "pathway", variable.name="gene", value.name="value") %>% merge(tmp_filt[,c("gene","cluster")], allow.cartesian=T, by="gene")
# Perform Gene ontology enrichment per cluster
go_list <- list()
for (c in unique(asd$cluster)) {
go_list[[c]] <- asd[,.(p=fisher.test(x=matrix(data=c(.SD[cluster==c & value==1,.N],
.SD[cluster!=c & value==1,.N],
.SD[cluster==c & value==0,.N],
.SD[cluster!=c & value==0,.N]),
nrow=2, ncol=2), alternative="greater")[["p.value"]]), by="pathway"] %>% .[,padj:=p.adjust(p, method = "fdr")]
}
opts$threshold_fdr <- 0.01
go_results <- lapply(names(go_list), function(x) go_list[[x]][padj<=opts$threshold_fdr] %>% .[,cluster:=x]) %>% rbindlist
View(go_results)
library(data.table)
library(purrr)
library(ggplot2)
io <- list()
opts <- list()
## Define I/O ##
io$sample.metadata <- "/Users/ricard/data/gastrulation/sample_metadata_scNMT.txt"
io$gene.metadata <- "/Users/ricard/data/ensembl/mouse/v87/BioMart/mRNA/Mmusculus_genes_BioMart.87.txt"
io$data.dir <- "/Users/ricard/data/gastrulation/met/feature_level"
io$features.dir <- "/Users/ricard/data/gastrulation/features/genomic_contexts"
io$outdir <- "/Users/ricard/gastrulation/met/differential/feature_level/out"
## Define options ##
# Define which annotations to look at
# opts$annos <- c("prom_2000_2000","genebody","E6.5_Distal_H3K27ac","E3.5_Distal_H3K27ac","CGI")
opts$annos <- c(
# "genebody"="Gene body",
# "prom_2000_2000_cgi"="CGI promoters"
# "prom_2000_2000_noncgi"="non-CGI promoters"
"prom_2000_2000"="Promoters"
# "CGI"="CpG islands",
# "exons"="Exons",
# "introns"="Introns",
)
# Define which stage and lineages to look at
opts$stage_lineage <- c("E6.5_EPI","E6.75_EPI","E6.5_PS","E6.75_PS")
# Filtering criteria
opts$min.cpgs <- 3          # Minimum number of observed CpG sites (per feature)
opts$min.cells <- 10         # Minimum number of observed cells per stage_lineage (per feature)
# opts$min.coverage <- 0.25
# opts$fraction.sites <- 1.0
# Define which cells to use
opts$cells <- fread(io$sample.metadata, stringsAsFactors = TRUE) %>%
.[,stage_lineage:=paste(stage,lineage,sep="_")] %>%
.[pass_metQC==T & stage_lineage%in%opts$stage_lineage,id_met]
sample_metadata <- fread(io$sample.metadata) %>% .[id_met%in%opts$cells] %>%
.[,stage_lineage:=as.factor(paste(stage,lineage,sep="_"))]
data <- lapply(names(opts$annos), function(n) fread(sprintf("zcat < %s/%s.tsv.gz",io$data.dir,n), showProgress=FALSE, stringsAsFactors = TRUE)) %>% rbindlist
colnames(data) <- c("id_met","id","anno","rate","Nmet","N")
# feature_metadata <- lapply(names(opts$annos), function(n) fread(sprintf("%s/%s.bed",io$features.dir,n), showProgress=F)) %>% rbindlist
# colnames(feature_metadata) <- c("chr","start","end","strand","id","anno")
# Merge methylation data and sample metadata
data <- data %>% merge(sample_metadata[,c("id_met","stage","stage_lineage")], by="id_met") %>% setkey(anno)
# Convert beta value to M value
# data[,m:=log2(((rate/100)+0.01)/(1-(rate/100)+0.01))]
# Filter features by minimum number of observed CpG sites
data <- data[N>=opts$min.cpgs]
# Filter features by minimum number of observed cells
for (sl in unique(data$stage)) {
data[stage==sl,Ntotal:=sample_metadata[stage==sl,.N]]
}
keep_cov_sites <- data %>% split(.$stage) %>% map(~ .[, cov:=.N, by=c("id","anno")] %>% .[cov >= opts$min.cells] %>% .[,id_anno:=paste(id,anno,sep="_")] %>% .$id_anno)
data <- data %>% .[,id_anno:=paste(id,anno,sep="_")] %>% .[id_anno%in%Reduce("intersect",keep_cov_sites)] %>%
.[,c("Ntotal","id_anno"):=NULL]
# Filter by variance
# keep_hv_sites <- data %>% split(.$anno) %>% map(~ .[,.(var = var(rate)), by="id"] %>% setorder(-var)  %>% head(n = nrow(.) * opts$fraction.sites) %>% .$id)
# data <- data %>% split(.$anno) %>% map2(.,names(.), function(x,y) x[id %in% keep_hv_sites[[y]]]) %>% rbindlist
foo <- data[,.(rate=sum(Nmet)/sum(N)), by=c("id","stage")]
head(foo)
# h <- hclust(dist(t(baz)))
# c <- cutree(h, k=2)
# baz <- merge(bar, data.table(id=names(c), cluster=as.factor(c)), by="id")
foo <- data[,.(rate=sum(Nmet)/sum(N)), by=c("id","stage")]
bar <- foo %>% dcast(id~stage, value.var="rate") %>% .[,diff:=E7.5-E6.5] %>%
.[,cluster:=cut(diff, breaks = c(0,0.05,0.25,1.0))] %>% .[,diff:=NULL] %>%
.[cluster!="(0.05,0.25]"] %>%
# .[,cluster:=ifelse(diff>0.25,"A","B")] %>% .[,cluster:=as.factor(cluster)] %>% .[,diff:=NULL] %>%
melt(id.vars=c("id","cluster"), variable.name="stage", value.name="rate")
unique(foo$stage)
library(data.table)
library(purrr)
library(ggplot2)
io <- list()
opts <- list()
## Define I/O ##
io$sample.metadata <- "/Users/ricard/data/gastrulation/sample_metadata_scNMT.txt"
io$gene.metadata <- "/Users/ricard/data/ensembl/mouse/v87/BioMart/mRNA/Mmusculus_genes_BioMart.87.txt"
io$data.dir <- "/Users/ricard/data/gastrulation/met/feature_level"
io$features.dir <- "/Users/ricard/data/gastrulation/features/genomic_contexts"
io$outdir <- "/Users/ricard/gastrulation/met/differential/feature_level/out"
## Define options ##
# Define which annotations to look at
# opts$annos <- c("prom_2000_2000","genebody","E6.5_Distal_H3K27ac","E3.5_Distal_H3K27ac","CGI")
opts$annos <- c(
# "genebody"="Gene body",
# "prom_2000_2000_cgi"="CGI promoters"
# "prom_2000_2000_noncgi"="non-CGI promoters"
"prom_2000_2000"="Promoters"
# "CGI"="CpG islands",
# "exons"="Exons",
# "introns"="Introns",
)
# Define which stage and lineages to look at
opts$stage_lineage <- c("E6.5_EPI","E6.75_EPI","E6.5_PS","E6.75_PS","E7.5_Ectoderm","E7.5_Mesoderm","E7.5_Endoderm")
# Filtering criteria
opts$min.cpgs <- 3          # Minimum number of observed CpG sites (per feature)
opts$min.cells <- 10         # Minimum number of observed cells per stage_lineage (per feature)
# opts$min.coverage <- 0.25
# opts$fraction.sites <- 1.0
# Define which cells to use
opts$cells <- fread(io$sample.metadata, stringsAsFactors = TRUE) %>%
.[,stage_lineage:=paste(stage,lineage,sep="_")] %>%
.[pass_metQC==T & stage_lineage%in%opts$stage_lineage,id_met]
sample_metadata <- fread(io$sample.metadata) %>% .[id_met%in%opts$cells] %>%
.[,stage_lineage:=as.factor(paste(stage,lineage,sep="_"))]
data <- lapply(names(opts$annos), function(n) fread(sprintf("zcat < %s/%s.tsv.gz",io$data.dir,n), showProgress=FALSE, stringsAsFactors = TRUE)) %>% rbindlist
colnames(data) <- c("id_met","id","anno","rate","Nmet","N")
# feature_metadata <- lapply(names(opts$annos), function(n) fread(sprintf("%s/%s.bed",io$features.dir,n), showProgress=F)) %>% rbindlist
# colnames(feature_metadata) <- c("chr","start","end","strand","id","anno")
# Merge methylation data and sample metadata
data <- data %>% merge(sample_metadata[,c("id_met","stage","stage_lineage")], by="id_met") %>% setkey(anno)
# Convert beta value to M value
# data[,m:=log2(((rate/100)+0.01)/(1-(rate/100)+0.01))]
# Filter features by minimum number of observed CpG sites
data <- data[N>=opts$min.cpgs]
# Filter features by minimum number of observed cells
for (sl in unique(data$stage)) {
data[stage==sl,Ntotal:=sample_metadata[stage==sl,.N]]
}
keep_cov_sites <- data %>% split(.$stage) %>% map(~ .[, cov:=.N, by=c("id","anno")] %>% .[cov >= opts$min.cells] %>% .[,id_anno:=paste(id,anno,sep="_")] %>% .$id_anno)
data <- data %>% .[,id_anno:=paste(id,anno,sep="_")] %>% .[id_anno%in%Reduce("intersect",keep_cov_sites)] %>%
.[,c("Ntotal","id_anno"):=NULL]
# Filter by variance
# keep_hv_sites <- data %>% split(.$anno) %>% map(~ .[,.(var = var(rate)), by="id"] %>% setorder(-var)  %>% head(n = nrow(.) * opts$fraction.sites) %>% .$id)
# data <- data %>% split(.$anno) %>% map2(.,names(.), function(x,y) x[id %in% keep_hv_sites[[y]]]) %>% rbindlist
# for (i in opts$annos) {
#   baz <- data[anno==i,c("id_met","id","rate")] %>% dcast(id_met~id, value.var="rate") %>%
#     as.data.frame %>% tibble::column_to_rownames("id_met") %>% as.matrix
#   pheatmap::pheatmap(as.matrix(baz), cluster_rows = T, cluster_cols = T, show_rownames = F, show_colnames = F)
# }
# h <- hclust(dist(t(baz)))
# c <- cutree(h, k=2)
# baz <- merge(bar, data.table(id=names(c), cluster=as.factor(c)), by="id")
foo <- data[,.(rate=sum(Nmet)/sum(N)), by=c("id","stage")]
bar <- foo %>% dcast(id~stage, value.var="rate") %>% .[,diff:=E7.5-E6.5] %>%
.[,cluster:=cut(diff, breaks = c(0,0.05,0.25,1.0))] %>% .[,diff:=NULL] %>%
.[cluster!="(0.05,0.25]"] %>%
# .[,cluster:=ifelse(diff>0.25,"A","B")] %>% .[,cluster:=as.factor(cluster)] %>% .[,diff:=NULL] %>%
melt(id.vars=c("id","cluster"), variable.name="stage", value.name="rate")
p <- ggplot(bar, aes(x=cluster, y=rate, fill=stage)) +
geom_boxplot(alpha=1.0, outlier.shape = NA) +
theme_bw() +
theme(
axis.text.x = element_text(colour="black",size=rel(1.5), angle=90, hjust=1, vjust=0.5)
)
print(p)
sample_metadata[stage=="E6.75",stage:="E6.5"] %>% .[,stage_lineage:=as.factor(paste(stage,lineage,sep="_"))]
data <- lapply(names(opts$annos), function(n) fread(sprintf("zcat < %s/%s.tsv.gz",io$data.dir,n), showProgress=FALSE, stringsAsFactors = TRUE)) %>% rbindlist
colnames(data) <- c("id_met","id","anno","rate","Nmet","N")
# Merge methylation data and sample metadata
data <- data %>% merge(sample_metadata[,c("id_met","stage","stage_lineage")], by="id_met") %>% setkey(anno)
# Convert beta value to M value
# data[,m:=log2(((rate/100)+0.01)/(1-(rate/100)+0.01))]
# Filter features by minimum number of observed CpG sites
data <- data[N>=opts$min.cpgs]
# Filter features by minimum number of observed cells
for (sl in unique(data$stage)) {
data[stage==sl,Ntotal:=sample_metadata[stage==sl,.N]]
}
keep_cov_sites <- data %>% split(.$stage) %>% map(~ .[, cov:=.N, by=c("id","anno")] %>% .[cov >= opts$min.cells] %>% .[,id_anno:=paste(id,anno,sep="_")] %>% .$id_anno)
data <- data %>% .[,id_anno:=paste(id,anno,sep="_")] %>% .[id_anno%in%Reduce("intersect",keep_cov_sites)] %>%
.[,c("Ntotal","id_anno"):=NULL]
# Filter by variance
# keep_hv_sites <- data %>% split(.$anno) %>% map(~ .[,.(var = var(rate)), by="id"] %>% setorder(-var)  %>% head(n = nrow(.) * opts$fraction.sites) %>% .$id)
# data <- data %>% split(.$anno) %>% map2(.,names(.), function(x,y) x[id %in% keep_hv_sites[[y]]]) %>% rbindlist
# h <- hclust(dist(t(baz)))
# c <- cutree(h, k=2)
# baz <- merge(bar, data.table(id=names(c), cluster=as.factor(c)), by="id")
foo <- data[,.(rate=sum(Nmet)/sum(N)), by=c("id","stage")]
bar <- foo %>% dcast(id~stage, value.var="rate") %>% .[,diff:=E7.5-E6.5] %>%
.[,cluster:=cut(diff, breaks = c(0,0.05,0.25,1.0))] %>% .[,diff:=NULL] %>%
.[cluster!="(0.05,0.25]"] %>%
# .[,cluster:=ifelse(diff>0.25,"A","B")] %>% .[,cluster:=as.factor(cluster)] %>% .[,diff:=NULL] %>%
melt(id.vars=c("id","cluster"), variable.name="stage", value.name="rate")
p <- ggplot(bar, aes(x=cluster, y=rate, fill=stage)) +
geom_boxplot(alpha=1.0, outlier.shape = NA) +
theme_bw() +
theme(
axis.text.x = element_text(colour="black",size=rel(1.5), angle=90, hjust=1, vjust=0.5)
)
print(p)
head(bar)
View(bar)
# Convert from ensembl ID to gene ID
gene.metadata <- fread(io$gene.metadata) %>% .[,c("ens_id","symbol")] %>% setnames(c("id","gene"))
tmp <- merge(bar, gene.metadata, by="id")
# I/O Reactome
io$reactomeFile <- "/Users/ricard/data/reactome/v59/mus_musculus/out/mouse_v75_reactome.rds"
io$reactomeFile2 <- "/Users/ricard/data/reactome/v59/mus_musculus/AllPathways.txt"
# Load reactome files
reactome <- readRDS(io$reactomeFile); colnames(reactome) <- toupper(colnames(reactome))
reactome.tmp <- read.table(io$reactomeFile2, header=F, quote="", sep="\t", stringsAsFactors=F)[,c(1,2)]
reactome_meta <- reactome.tmp[,2]; names(reactome_meta) <- reactome.tmp[,1]
rownames(reactome) <- stringr::str_replace_all(rownames(reactome), reactome_meta)
feature.sets <- reactome
# I/O MSigDB
io$msigFile <- "/Users/ricard/data/MSigDB/v6.0/mus_musculus/C5/bp_binary_matrix_ensembl.rds"
# io$msigFile <- "/Users/ricard/data/MSigDB/v6.0/mus_musculus/C2/binary_matrix_ensembl.rds"
# Load MSigDB files
feature.sets <- readRDS(io$msigFile)
# Filter feature sets with small number of features
opts$min.size <- 10
feature.sets <- feature.sets[rowSums(feature.sets)>=opts$min.size,]
# Remove features that do not intersect between the feature sets and the data
features <- intersect(toupper(tmp$gene),colnames(feature.sets))
tmp_filt <- tmp[,gene:=toupper(gene)] %>% .[gene %in% features]
feature.sets_filt <- feature.sets[,features]
asd <- melt.data.table(as.data.table(feature.sets_filt, keep.rownames="pathway"), id.vars = "pathway", variable.name="gene", value.name="value") %>% merge(tmp_filt[,c("gene","cluster")], allow.cartesian=T, by="gene")
# Perform Gene ontology enrichment per cluster
go_list <- list()
for (c in unique(asd$cluster)) {
go_list[[c]] <- asd[,.(p=fisher.test(x=matrix(data=c(.SD[cluster==c & value==1,.N],
.SD[cluster!=c & value==1,.N],
.SD[cluster==c & value==0,.N],
.SD[cluster!=c & value==0,.N]),
nrow=2, ncol=2), alternative="greater")[["p.value"]]), by="pathway"] %>% .[,padj:=p.adjust(p, method = "fdr")]
}
opts$threshold_fdr <- 0.01
go_results <- lapply(names(go_list), function(x) go_list[[x]][padj<=opts$threshold_fdr] %>% .[,cluster:=x]) %>% rbindlist
View(go_results)
asd
table(bar$cluster)
# h <- hclust(dist(t(baz)))
# c <- cutree(h, k=2)
# baz <- merge(bar, data.table(id=names(c), cluster=as.factor(c)), by="id")
foo <- data[,.(rate=sum(Nmet)/sum(N)), by=c("id","stage")]
bar <- foo %>% dcast(id~stage, value.var="rate") %>% .[,diff:=E7.5-E6.5] %>%
.[,cluster:=cut(diff, breaks = c(0,0.05,0.10,1.0))] %>% .[,diff:=NULL] %>%
.[cluster!="(0.05,0.10]"] %>%
# .[,cluster:=ifelse(diff>0.25,"A","B")] %>% .[,cluster:=as.factor(cluster)] %>% .[,diff:=NULL] %>%
melt(id.vars=c("id","cluster"), variable.name="stage", value.name="rate")
p <- ggplot(bar, aes(x=cluster, y=rate, fill=stage)) +
geom_boxplot(alpha=1.0, outlier.shape = NA) +
theme_bw() +
theme(
axis.text.x = element_text(colour="black",size=rel(1.5), angle=90, hjust=1, vjust=0.5)
)
print(p)
table(bar$cluster)
bar <- foo %>% dcast(id~stage, value.var="rate") %>% .[,diff:=E7.5-E6.5] %>%
.[,cluster:=cut(diff, breaks = c(0,0.05,0.15,1.0))] %>% .[,diff:=NULL] %>%
.[cluster!="(0.05,0.1]"] %>%
# .[,cluster:=ifelse(diff>0.25,"A","B")] %>% .[,cluster:=as.factor(cluster)] %>% .[,diff:=NULL] %>%
melt(id.vars=c("id","cluster"), variable.name="stage", value.name="rate")
table(bar$cluster)
bar <- foo %>% dcast(id~stage, value.var="rate") %>% .[,diff:=E7.5-E6.5] %>%
.[,cluster:=cut(diff, breaks = c(0,0.05,0.15,1.0))] %>% .[,diff:=NULL] %>%
.[cluster!="(0.05,0.15]"] %>%
# .[,cluster:=ifelse(diff>0.25,"A","B")] %>% .[,cluster:=as.factor(cluster)] %>% .[,diff:=NULL] %>%
melt(id.vars=c("id","cluster"), variable.name="stage", value.name="rate")
table(bar$cluster)
# Convert from ensembl ID to gene ID
gene.metadata <- fread(io$gene.metadata) %>% .[,c("ens_id","symbol")] %>% setnames(c("id","gene"))
tmp <- merge(bar, gene.metadata, by="id")
# I/O Reactome
io$reactomeFile <- "/Users/ricard/data/reactome/v59/mus_musculus/out/mouse_v75_reactome.rds"
io$reactomeFile2 <- "/Users/ricard/data/reactome/v59/mus_musculus/AllPathways.txt"
# Load reactome files
reactome <- readRDS(io$reactomeFile); colnames(reactome) <- toupper(colnames(reactome))
reactome.tmp <- read.table(io$reactomeFile2, header=F, quote="", sep="\t", stringsAsFactors=F)[,c(1,2)]
reactome_meta <- reactome.tmp[,2]; names(reactome_meta) <- reactome.tmp[,1]
rownames(reactome) <- stringr::str_replace_all(rownames(reactome), reactome_meta)
feature.sets <- reactome
# I/O MSigDB
io$msigFile <- "/Users/ricard/data/MSigDB/v6.0/mus_musculus/C5/bp_binary_matrix_ensembl.rds"
# io$msigFile <- "/Users/ricard/data/MSigDB/v6.0/mus_musculus/C2/binary_matrix_ensembl.rds"
# Load MSigDB files
feature.sets <- readRDS(io$msigFile)
# Filter feature sets with small number of features
opts$min.size <- 10
feature.sets <- feature.sets[rowSums(feature.sets)>=opts$min.size,]
# Remove features that do not intersect between the feature sets and the data
features <- intersect(toupper(tmp$gene),colnames(feature.sets))
tmp_filt <- tmp[,gene:=toupper(gene)] %>% .[gene %in% features]
feature.sets_filt <- feature.sets[,features]
asd <- melt.data.table(as.data.table(feature.sets_filt, keep.rownames="pathway"), id.vars = "pathway", variable.name="gene", value.name="value") %>% merge(tmp_filt[,c("gene","cluster")], allow.cartesian=T, by="gene")
# Perform Gene ontology enrichment per cluster
go_list <- list()
for (c in unique(asd$cluster)) {
go_list[[c]] <- asd[,.(p=fisher.test(x=matrix(data=c(.SD[cluster==c & value==1,.N],
.SD[cluster!=c & value==1,.N],
.SD[cluster==c & value==0,.N],
.SD[cluster!=c & value==0,.N]),
nrow=2, ncol=2), alternative="greater")[["p.value"]]), by="pathway"] %>% .[,padj:=p.adjust(p, method = "fdr")]
}
opts$threshold_fdr <- 0.01
go_results <- lapply(names(go_list), function(x) go_list[[x]][padj<=opts$threshold_fdr] %>% .[,cluster:=x]) %>% rbindlist
View(go_results)
library(data.table)
library(purrr)
library(ggplot2)
io <- list()
opts <- list()
## Define I/O ##
io$sample.metadata <- "/Users/ricard/data/gastrulation/sample_metadata_scNMT.txt"
io$gene.metadata <- "/Users/ricard/data/ensembl/mouse/v87/BioMart/mRNA/Mmusculus_genes_BioMart.87.txt"
io$data.dir <- "/Users/ricard/data/gastrulation/met/feature_level"
io$features.dir <- "/Users/ricard/data/gastrulation/features/genomic_contexts"
io$outdir <- "/Users/ricard/gastrulation/met/differential/feature_level/out"
## Define options ##
# Define which annotations to look at
# opts$annos <- c("prom_2000_2000","genebody","E6.5_Distal_H3K27ac","E3.5_Distal_H3K27ac","CGI")
opts$annos <- c(
# "genebody"="Gene body",
# "prom_2000_2000_cgi"="CGI promoters"
# "prom_2000_2000_noncgi"="non-CGI promoters"
"prom_2000_2000"="Promoters"
# "CGI"="CpG islands",
# "exons"="Exons",
# "introns"="Introns",
)
# Define which stage and lineages to look at
opts$stage_lineage <- c("E6.5_EPI","E6.75_EPI","E6.5_PS","E6.75_PS","E7.5_Ectoderm","E7.5_Mesoderm","E7.5_Endoderm")
# Filtering criteria
opts$min.cpgs <- 3          # Minimum number of observed CpG sites (per feature)
opts$min.cells <- 10         # Minimum number of observed cells per stage_lineage (per feature)
# opts$min.coverage <- 0.25
# opts$fraction.sites <- 1.0
# Define which cells to use
opts$cells <- fread(io$sample.metadata, stringsAsFactors = TRUE) %>%
.[,stage_lineage:=paste(stage,lineage,sep="_")] %>%
.[pass_metQC==T & stage_lineage%in%opts$stage_lineage,id_met]
sample_metadata <- fread(io$sample.metadata) %>% .[id_met%in%opts$cells] %>%
.[,stage_lineage:=as.factor(paste(stage,lineage,sep="_"))]
sample_metadata[stage=="E6.75",stage:="E6.5"] %>% .[,stage_lineage:=as.factor(paste(stage,lineage,sep="_"))]
data <- lapply(names(opts$annos), function(n) fread(sprintf("zcat < %s/%s.tsv.gz",io$data.dir,n), showProgress=FALSE, stringsAsFactors = TRUE)) %>% rbindlist
colnames(data) <- c("id_met","id","anno","rate","Nmet","N")
# feature_metadata <- lapply(names(opts$annos), function(n) fread(sprintf("%s/%s.bed",io$features.dir,n), showProgress=F)) %>% rbindlist
# colnames(feature_metadata) <- c("chr","start","end","strand","id","anno")
# Merge methylation data and sample metadata
data <- data %>% merge(sample_metadata[,c("id_met","stage","stage_lineage")], by="id_met") %>% setkey(anno)
# Convert beta value to M value
# data[,m:=log2(((rate/100)+0.01)/(1-(rate/100)+0.01))]
# Filter features by minimum number of observed CpG sites
data <- data[N>=opts$min.cpgs]
# Filter features by minimum number of observed cells
for (sl in unique(data$stage)) {
data[stage==sl,Ntotal:=sample_metadata[stage==sl,.N]]
}
keep_cov_sites <- data %>% split(.$stage) %>% map(~ .[, cov:=.N, by=c("id","anno")] %>% .[cov >= opts$min.cells] %>% .[,id_anno:=paste(id,anno,sep="_")] %>% .$id_anno)
data <- data %>% .[,id_anno:=paste(id,anno,sep="_")] %>% .[id_anno%in%Reduce("intersect",keep_cov_sites)] %>%
.[,c("Ntotal","id_anno"):=NULL]
# Filter by variance
# keep_hv_sites <- data %>% split(.$anno) %>% map(~ .[,.(var = var(rate)), by="id"] %>% setorder(-var)  %>% head(n = nrow(.) * opts$fraction.sites) %>% .$id)
# data <- data %>% split(.$anno) %>% map2(.,names(.), function(x,y) x[id %in% keep_hv_sites[[y]]]) %>% rbindlist
# for (i in opts$annos) {
#   baz <- data[anno==i,c("id_met","id","rate")] %>% dcast(id_met~id, value.var="rate") %>%
#     as.data.frame %>% tibble::column_to_rownames("id_met") %>% as.matrix
#   pheatmap::pheatmap(as.matrix(baz), cluster_rows = T, cluster_cols = T, show_rownames = F, show_colnames = F)
# }
# h <- hclust(dist(t(baz)))
# c <- cutree(h, k=2)
# baz <- merge(bar, data.table(id=names(c), cluster=as.factor(c)), by="id")
foo <- data[,.(rate=sum(Nmet)/sum(N)), by=c("id","stage")]
bar <- foo %>% dcast(id~stage, value.var="rate") %>% .[,diff:=E7.5-E6.5] %>%
.[,cluster:=cut(diff, breaks = c(0,0.05,0.15,1.0))] %>% .[,diff:=NULL] %>%
.[cluster!="(0.05,0.15]"] %>%
# .[,cluster:=ifelse(diff>0.25,"A","B")] %>% .[,cluster:=as.factor(cluster)] %>% .[,diff:=NULL] %>%
melt(id.vars=c("id","cluster"), variable.name="stage", value.name="rate")
# p <- ggplot(bar, aes(x=cluster, y=rate, fill=stage)) +
#   geom_boxplot(alpha=1.0, outlier.shape = NA) +
#   theme_bw() +
#   theme(
#     axis.text.x = element_text(colour="black",size=rel(1.5), angle=90, hjust=1, vjust=0.5)
#   )
# print(p)
table(bar$cluster)
diffrna <- fread("/Users/ricard/gastrulation/rna/differential/out/E6.5_vs_E7.5.tsv") %>%
setnames(c("symbol","diff","sig","padj_fdr"),c("gene","rna.diff","rna.sig","rna.pvalue"))
foo <- merge(
bar[,c("id","cluster")],
diffrna[,c("id","gene","rna.pvalue","rna.sig","rna.diff")],
by=c("id")
) %>% .[complete.cases(.)]
# Roughly 50% of the genes are upregulated and 50% are downregulated
mean(diffrna[rna.sig==TRUE,rna.diff]>0)
mean(diffrna[rna.sig==TRUE,rna.diff]<0)
# For the upregulated genes, less than 5% can be explained by DNA methylation
foo[rna.sig==TRUE & rna.diff>2, table(cluster)]
# For the upregulated genes, 50% also gain methylation
foo[rna.sig==TRUE & rna.diff>1, table(cluster)]
# For the downregulated genes, more than 50% can be explained by changes in DNA methylation
foo[rna.sig==TRUE & rna.diff<(-1), table(cluster)]
# For the downregulated genes, more than 50% can be explained by changes in DNA methylation
foo[rna.sig==TRUE & rna.diff<(-2), table(cluster)]
# For the upregulated genes, 50% also gain methylation
foo[rna.sig==TRUE & rna.diff>1.5, table(cluster)]
# For the downregulated genes, more than 50% can be explained by changes in DNA methylation
foo[rna.sig==TRUE & rna.diff<(-1.5), table(cluster)]
# For the upregulated genes, 50% also gain methylation
foo[rna.sig==TRUE & rna.diff>1.5, table(cluster)]
foo[,mean(rna.sig==TRUE),by="cluster"]
# 2
foo[,mean(rna.sig==TRUE & abs(rna.diff)>1.5),by="cluster"]
foo[cluster=="(0.5,1]" & rna.sig==TRUE, mean(rna.diff>0),by="cluster"]
foo[cluster=="(0,0.05]" & rna.sig==TRUE, mean(rna.diff>0),by="cluster"]
